# 行列行列積最適化課題 実行手順書

## 課題概要

行列行列積の実行性能について、以下の最適化技法を組み合わせて最高性能を探索する：
- ブロッキング（ループタイリング）
- ループアンローリング（命令レベル並列性）
- OpenMP（スレッドレベル並列化）
- AVX2（ベクトル化）
- MKLライブラリ

## 1. 環境準備

### 1.1 基本環境の確認
```bash
# CPU情報の確認
lscpu

# コンパイラの確認
which gcc
which icc
gcc --version
icc --version

# OpenMPの確認
echo $OMP_NUM_THREADS
```

### 1.2 ディレクトリ移動
```bash
cd ComSystemII
```

## 2. 基本テスト

### 2.1 最適化なしの性能測定
```bash
# クリーンビルド
make clean
make

# 基本テスト実行
make run
```

### 2.2 Python版との比較（オプション）
```bash
# Python版の実行（数分かかる）
python3 mm.py
```

## 3. 個別最適化技法のテスト

### 3.1 ブロッキング（ループタイリング）

#### 3.1.1 基本ブロッキング
```bash
# ブロッキングを有効化
sed -i 's|//#define BLOCKING|#define BLOCKING|' gemm-test.c
make clean
make
make run

# 元に戻す
sed -i 's|#define BLOCKING|//#define BLOCKING|' gemm-test.c
```

#### 3.1.2 様々なブロックサイズのテスト
```bash
# ブロックサイズ16
sed -i 's/#define BLOCKSIZE 32/#define BLOCKSIZE 16/' gemm-test.c
sed -i 's|//#define BLOCKING|#define BLOCKING|' gemm-test.c
make clean
make
make run

# ブロックサイズ64
sed -i 's/#define BLOCKSIZE 16/#define BLOCKSIZE 64/' gemm-test.c
make clean
make
make run

# ブロックサイズ128
sed -i 's/#define BLOCKSIZE 64/#define BLOCKSIZE 128/' gemm-test.c
make clean
make
make run

# 元に戻す
sed -i 's/#define BLOCKSIZE 128/#define BLOCKSIZE 32/' gemm-test.c
sed -i 's|#define BLOCKING|//#define BLOCKING|' gemm-test.c
```

### 3.2 AVX2ベクトル化
```bash
# AVX2を有効化
sed -i 's|//#define AVX2|#define AVX2|' gemm-test.c
make clean
make
make run

# 元に戻す
sed -i 's|#define AVX2|//#define AVX2|' gemm-test.c
```

### 3.3 OpenMP並列化
```bash
# OpenMPを有効化
sed -i 's|//#define OMP|#define OMP|' gemm-test.c
make clean
make

# 様々なスレッド数でテスト
export OMP_NUM_THREADS=1
make run

export OMP_NUM_THREADS=2
make run

export OMP_NUM_THREADS=4
make run

export OMP_NUM_THREADS=8
make run

# 元に戻す
sed -i 's|#define OMP|//#define OMP|' gemm-test.c
```

### 3.4 AVX2 + OpenMP組み合わせ
```bash
# AVX2 + OpenMPを有効化
sed -i 's|//#define AVX_OMP|#define AVX_OMP|' gemm-test.c
make clean
make

# 様々なスレッド数でテスト
export OMP_NUM_THREADS=1
make run

export OMP_NUM_THREADS=2
make run

export OMP_NUM_THREADS=4
make run

export OMP_NUM_THREADS=8
make run

# 元に戻す
sed -i 's|#define AVX_OMP|//#define AVX_OMP|' gemm-test.c
```

### 3.5 MKLライブラリ
```bash
# MKLを有効化
sed -i 's|//#define MKL|#define MKL|' gemm-test.c
make clean
make
make run

# 元に戻す
sed -i 's|#define MKL|//#define MKL|' gemm-test.c
```

## 4. ループアンローリングの実装

### 4.1 コードの追加
`gemm-test.c`に以下の関数を追加：

```c
/* Loop Unrolling */
void dgemm_unroll(REAL *A, REAL *B, REAL *C, int n)
{
  int i, j, k;
  REAL cij;
  int unroll_factor = UNROLL;

  for (i = 0; i < n; i++)
    for (j = 0; j < n; j++)
    {
      cij = C[i + j * n];
      for (k = 0; k < n - unroll_factor + 1; k += unroll_factor)
      {
        cij += A[i + k * n] * B[k + j * n];
        cij += A[i + (k+1) * n] * B[(k+1) + j * n];
        cij += A[i + (k+2) * n] * B[(k+2) + j * n];
        cij += A[i + (k+3) * n] * B[(k+3) + j * n];
      }
      // 残りの要素を処理
      for (; k < n; k++)
        cij += A[i + k * n] * B[k + j * n];
      C[i + j * n] = cij;
    }
}
```

### 4.2 main関数への追加
`gemm-test.c`のdefine部分に追加：
```c
//#define UNROLL_ONLY                   /* Loop Unrolling -> ON */
```

main関数のテスト部分に追加：
```c
#ifdef UNROLL_ONLY
    int_mat(A, B, C, N);
    t = seconds();
    dgemm_unroll(A, B, C, N);
    t = seconds() - t;
    check_mat(C, C_unopt, N);
    printf("%f [s]  GFLOPS %f  |Loop Unrolling|\n", t,
           (float)N * N * N * 2 / t / 1000 / 1000 / 1000);
#endif
```

### 4.3 ループアンローリングのテスト
```bash
# ループアンローリングを有効化
sed -i 's|//#define UNROLL_ONLY|#define UNROLL_ONLY|' gemm-test.c
make clean
make
make run

# 元に戻す
sed -i 's|#define UNROLL_ONLY|//#define UNROLL_ONLY|' gemm-test.c
```

## 5. 自動化スクリプトの作成

### 5.1 テストスクリプトの作成
`optimization_test.sh`を作成：

```bash
#!/bin/bash

echo "=== 行列行列積最適化性能テスト ===" > results.txt
echo "実行日時: $(date)" >> results.txt
echo "" >> results.txt

# 基本テスト
echo "1. 基本テスト（最適化なし）" >> results.txt
make clean
make
make run >> results.txt
echo "" >> results.txt

# ブロッキングテスト（様々なブロックサイズ）
for block_size in 16 32 64 128; do
    echo "2. ブロッキングテスト（ブロックサイズ: $block_size）" >> results.txt
    sed -i "s/#define BLOCKSIZE [0-9]*/#define BLOCKSIZE $block_size/" gemm-test.c
    sed -i 's|//#define BLOCKING|#define BLOCKING|' gemm-test.c
    make clean
    make
    make run >> results.txt
    echo "" >> results.txt
    sed -i 's|#define BLOCKING|//#define BLOCKING|' gemm-test.c
done

# AVX2テスト
echo "3. AVX2テスト" >> results.txt
sed -i 's|//#define AVX2|#define AVX2|' gemm-test.c
make clean
make
make run >> results.txt
echo "" >> results.txt
sed -i 's|#define AVX2|//#define AVX2|' gemm-test.c

# OpenMPテスト（様々なスレッド数）
echo "4. OpenMPテスト" >> results.txt
sed -i 's|//#define OMP|#define OMP|' gemm-test.c
make clean
make
for threads in 1 2 4 8; do
    echo "スレッド数: $threads" >> results.txt
    export OMP_NUM_THREADS=$threads
    make run >> results.txt
    echo "" >> results.txt
done
sed -i 's|#define OMP|//#define OMP|' gemm-test.c

# AVX2 + OpenMPテスト
echo "5. AVX2 + OpenMPテスト" >> results.txt
sed -i 's|//#define AVX_OMP|#define AVX_OMP|' gemm-test.c
make clean
make
for threads in 1 2 4 8; do
    echo "AVX2 + OpenMP スレッド数: $threads" >> results.txt
    export OMP_NUM_THREADS=$threads
    make run >> results.txt
    echo "" >> results.txt
done
sed -i 's|#define AVX_OMP|//#define AVX_OMP|' gemm-test.c

# MKLテスト
echo "6. MKLテスト" >> results.txt
sed -i 's|//#define MKL|#define MKL|' gemm-test.c
make clean
make
make run >> results.txt
echo "" >> results.txt
sed -i 's|#define MKL|//#define MKL|' gemm-test.c

echo "テスト完了！結果は results.txt に保存されました。"
```

### 5.2 スクリプトの実行
```bash
chmod +x optimization_test.sh
./optimization_test.sh
```

## 6. 結果の分析

### 6.1 性能ランキングの確認
```bash
# 最高性能の組み合わせを確認
grep "GFLOPS" results.txt | sort -k3 -nr | head -10
```

### 6.2 性能向上率の計算
```bash
# 基本性能と最高性能の比較
BASELINE=$(grep "unoptimized" results.txt | tail -1 | awk '{print $4}')
BEST=$(grep "GFLOPS" results.txt | sort -k3 -nr | head -1 | awk '{print $4}')
echo "基本性能: $BASELINE GFLOPS"
echo "最高性能: $BEST GFLOPS"
echo "性能向上率: $(echo "scale=2; $BEST / $BASELINE" | bc)x"
```

## 7. 考察のポイント

### 7.1 各最適化技法の効果分析
- **ブロッキング**: キャッシュ効率の向上効果
- **ループアンローリング**: 命令レベル並列性の活用効果
- **OpenMP**: スレッドレベル並列化の効果
- **AVX2**: SIMD並列化の効果

### 7.2 パラメータの最適化
- **ブロックサイズ**: 最適値とその理由
- **スレッド数**: スケーラビリティの分析
- **アンロール係数**: 命令レベル並列性の効果

### 7.3 組み合わせ効果
- 複数の最適化を組み合わせた場合の相乗効果
- 最適化の順序や依存関係の影響

### 7.4 ライブラリの重要性
- MKLライブラリの性能
- 手動最適化 vs ライブラリ最適化の比較
- ライブラリ使用の利点と欠点

## 8. レポート作成

### 8.1 結果の整理
- 各最適化技法の性能データ
- パラメータ別の性能比較
- 組み合わせ最適化の結果

### 8.2 考察
- 最高性能の組み合わせとその理由
- 各最適化技法の効果の定量的分析
- ライブラリの重要性に関する考察

### 8.3 結論
- 最適な最適化法の組み合わせ
- 性能向上の要因分析
- 今後の改善点

## 9. 注意事項

### 9.1 コンパイラ設定
- 現在のMakefileではIntel Compiler (icc)が使用されている
- GCCを使用する場合は`CC=gcc`のコメントを外す

### 9.2 行列サイズの制約
- AVX2を使用する場合、行列サイズは8の倍数である必要がある
- ブロッキングを使用する場合、行列サイズはBLOCKSIZEの倍数である必要がある

### 9.3 実行時間
- 各テストは数秒から数分かかる場合がある
- 全テストを実行する場合は十分な時間を確保する

### 9.4 結果の保存
- 各テストの結果は必ず記録する
- スクリプトを使用して自動的に結果を保存することを推奨
